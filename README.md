> SwiftCoordinatorsKit находится в стадии разработки и еще не выделен в отдельный проект. Вся документация на него ведется в данном репозитории.

# SwiftCoordinatorsKit (SCK)

Библиотека на Swift для внедрения и использования __координаторов__ в проекте.

__Платформа__: iOS UIKit

## Основные возможности SCK

Основная возможность SCK - это создание иерархии координаторов и вью контроллеров, каждый из которых может решать одну или несколько следующих задач:

1. Роутинг, т.е. управление логикой отображения сцен (вью контроллеров).
2. Работа с данными внутри иерархии.
 - Координатор может создавать данные и отправлять их в иерархию.
 - Координатор и вью контроллер могут принимать данные, передаваемые внутри иерархии.
 - Координатор может изменять и передавать дальше измененные данные.
 - Координатор и вью контроллер могут обрабатывать поступающие в них данные

Вся функциональность SCK основана на использовании протоколов, все взаимодействие всех элементов идет через протоколы. Функциональные возможности координаторов определяются перечнем протоколов из состава SCK, на которые они подписаны. SCK имеет ряд базовых реализаций координаторов уже наделенных предварительной функциональностью.

## Преимущества использования SCK

Использование SCK позволяет добиться следующих **преимуществ**:

- обеспечение максимально низкой связанности между элементами приложения (в частности между вью контроллерами);
- переиспользуемость сцен/вью контроллеров, их независимость от порядка и способа отображения;
- упрощение процесса передачи данных между сценами и внутри приложения, снятие этой обязанности с вью контроллеров;
- централизация определенной функциональности в одном месте (конкретный координатор позволяет повесить на себя решение определенных задач);
- повышения удобства тестирования (координатор может быть с легкостью замокан или протестирован).

## Описание 

### Создание иерархии координаторов и вью контроллеров

Координаторы реализуют структуру данных "Дерево", где у каждого координатора может быть один родитель и произвольное количество сыновей. Приложение должно иметь один главный координатор и множество дочерних, каждый из которых может иметь свое множество дочерних координаторов, и т.д.

На рисунке приведе пример структуры координаторов одной из версий приложения SubsTracker

(https://github.com/DobbyWanKenoby/SubsTracker/blob/main/_tmp/AppScheme.png)

Как видно в составе проекта присутствует главный координатор приложения `ApplicationCoordinator`, и множество подчиненных. 

`ApplicationCoordinator` производит предварительную настройку прилоежния, в том числе создавая все необходимые дочерние координаторы (в том числе микросервисы). 

`InitializationCoordinator` предназначен для инициализации данных приложения, он запускается и отображается первым после `ApplicationCoordinator`. В нем производится проверка наличия новых данных на сервера, а так же отображается "анимированный SplashScreen" с индикатором загрузки.

`FunctionalCoordinator` предназначен для решения основных функций приложения - управления списком подписок.

Как видно из примера, координаторы находятся состоянии "отец-сын", а некоторые контроллеры многократно переиспользуются в различных координаторах.

Так же из примера видно, что в составе проекта созданы несколько __микросервисов__, каждый из которых отвечает за реализацию какой-то уникальной функциональности внутри приложения, например сохранения определенной сущности в базу данных, или создание нотификаций, или получения данных из сети, или организация работы с CoreData и т.д.

### Роутинг

Координатор, при необходимости, может иметь множество подчиненных вью контроллеров (сцен), отображением которых он управляет. Стоит отметить, что один и тот же вью контроллер (разные экземпляры одного и того же класса) может быть подчиненным у разных координаторов.

Координатор имеет базовый презентер, в рамках которого отображаются подчиненные сцены. Обычно это TabBarController или NavigationController. Координатор определяет:

- логику отображения сцен (какая сцена и когда должна быть отображена).
- способ отображения сцен (present, в стеке Navigation Contoller и т.д.).
- наполняет вью контроллер данными в соответствии с его протоколом.

### Работа с данными внутри иерархии.

Внутри иерархии координаторов и вью контроллеров могут передаваться данные. Для этого используется специальный формат, имеющий название "Сигнал" (Signal). Сигнал, как и сигнал в физической среде, отправляется в иерархию и распространяется по всем ее элементам, каждый из которых может принять и обработать данные.
    
> **Пример**
> 
> Если на одном из экранов приложения создается некий объект, который должен быть распространен на другие экраны, то данные могут передаваться по иерархии координаторов, пока не достигнут места (или мест) назначения. 
> 
>     Например, приложение "Заметки". Экран создания "Заметки" не должен создавать заметку, он должен лишь предоставлять графический интерфейс для ее создания. После нажатия на кнопку "Сохранить" сущность "Заметка" упаковывается в Сигнал и отправляется по иерархии координаторов и вью контроллеров. При достижении экрана со списком заметок - она добавляется в него, а при достижении координатора, обеспечивающего сохранение заметок - она сохраняется в долговременное хранилище.




# Последующая документация не актуальна, данные дополняются





Приемники (протокол `Receiver`).

    Приемник предназначен для решения конкретного круга задач, например:
    * обеспечение сохранения и загрузки определенных данных. Где именно эти данные будут храниться - ответственность Приемника, важно, что он получив запрос - производит необходимые действия (сохраняет или загружает данные) и при необходимости отправляет ответ.
    * работа с нотификациями;
    * изменение данных в Table View.
    
    и т.д.
    
    Приемник может быть представлен координатором или контроллеров, он находится в иерархии кординаторов, и когда к нему через Трансмиттер прилетает запрос, то он отрабатывает его и при необходимости отвечает.
    
    На основе Приемника в проекте можно реализовать Микросервисы.


## Координаторы и потоки (flow) 

Координатор создается, когда в приложении необходимо выделить решение некоторой задачи. В контексте SCK такие задачи называются **потоками** (flow). Задачи - это условное наименование решаемых задач и в практике не используется при написании программного кода (за исключением названия методов `startFlow` и `finishFlow`). 

> **Пример**
> 
> Координатор `ApplicationCoordinator` может решать задачу обеспечения работы приложеняи в целом, в частности определения стартового экрана (в завиисмости от того, залогинен ли пользователь), загрузку вспомогательных библиотек и т.д. Образно говоря, он создает поток `Application`.
> 
> Координатор `AuthCoordinator` (будет дочерним по отношению к `ApplicationCoordinator`) может обеспечивать работу авторизированного пользователя и предоставлять доступ к соответствующим сценам (главынй экран приложения, экран настроек и т.д.).
> 
> Координатор `NotAuthCoordinator` (будет дочерним по отношению к `ApplicationCoordinator`) может обеспечивать работу неавторизированного пользователя и предоставлять доступ к соответствующим сценам (экран авторизации, регистрации и т.д.).

Дочерние координаторы функционируют в рамках родительского потока и создают свой собственный.

## Использование Координаторов


### protocol Coordinator

Базовый протокол, на который должен быть подписан любой Координатор. Его единственная задача - обеспечить хранение древовидной структуры координаторов.

